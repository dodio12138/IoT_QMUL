{"/IoT_QMUL/docs/get_started/en/conclusion/conclusion.html":{"title":"Conclusion","content":" title: Conclusion This project designs a prototype for recording and storing user location information, also called footprint card. The solution is designed using SSM methodology and covers both location recording and data transfer with knowledge of GPS, Bluetooth and other aspects. The board has also been selected so that it is small enough and easy to carry around, while taking into account the range. The prototype can now record the base movement and can store as well as transfer data. The solution design will be expanded again with UI, PCB and backup."},"/IoT_QMUL/docs/get_started/en/design/design.html":{"title":"Design","content":" title: Design ## SSM3: Root definition ### User World View The user carries the card on the move (input) and watches their footprint record in the phone (output). ### Smart Device World View Smart device detects movement (input), extracts information from GPS module and stores it (output). Smart device listen for Bluetooth pairing requests (input) and transmit data (output). The smart device detects the Wi Fi connection (input) and the user presses the button (input) for data backup to the server (output). ### Server World View The server detects the smart device request (input) and then accepts the data (input). The server detects that the user want to view (input) the data and then transmits the data (output). ### Smartphone World View The phone sends a Bluetooth pairing and transmission request (output), then accepts the data (input), and finally opens a browser to render the visualization (Output). ## SSM4: Conceptual modelling The following Hierarchical Task Analysis (HTA) model describes the different tasks and subtasks that need to be performed to achieve the desired goal. ![](../../assets/images/HTA1.png) ## SSM5: Comparison of model and Real World T1.1: The appropriate detection interval is chosen for low power consumption in the real world without the need for continuous detection. T1.2: Since GPS data callbacks have long time intervals, careful consideration needs to be given to the frequency of reading GPS data. T1.3: In reality, the screen doesn't need to be always on, set a rest button to keep the power consumption low. T2.1: Choose the way in which the card can passively or automatically connect to the user's network. ## SSM6: Changes of the model Based on the above comparative analysis with the real world, the final choice was to perform motion detection every 8 seconds to match the interval at which GPS receives satellite data."},"/IoT_QMUL/docs/get_started/en/evaluation/evaluation.html":{"title":"Evaluation","content":" title: Evaluation ## Recording test The test was carried out on journeys from Croydon to Queen Mary University of London (My primary route to school) in some day. Footprint cards can intermittently record and successfully save location information. In some narrow and metro sections, GPS signals cannot be received properly. In addition, signal loss also occurs at certain moments in open areas, and it is assumed that the probable cause is that the GPS signal was extracted at a time when the GPS fix phase was in progress, and that any subsequent time intervals need to be adjusted. The range was not tested as there is no corresponding battery design for this project yet. ## Display test The storage format is finalized in `csv` format. For the time being, third party software is used for map presentation. Below are screenshots: ![](../../assets/images/Screenshot.png) >! Due to some testing and debugging, some data points were incorrectly connected, but the approximate path can still be seen. It is also possible to import the `csv` into Google Earth for viewing by converting it to `KML` format using an online tool[^1], these will be demonstrated in a later video. ## Shortcomings Positioning is easily lost. The current Bluetooth connection is cumbersome and inflexible and requires an improved transmission method. Sketchy user interface. ## Future action Design a new set of UI. Optimization of data transfer methods. Design a circuit board containing a one to three power management module and charging module. Design Footprint Card Case. [^1]: https://mygeodata.cloud/converter/"},"/IoT_QMUL/docs/get_started/en/implementation/implementation.html":{"title":"Implementation","content":" title: Implementation ## Hardware development Since this is a prototype development, in this project a breadboard and an external power supply is used first. ### Proposed model architecture ![](../../assets/images/borad.png) The SDA and SCL of the OLED display are connected to the SDA and SCL of the board for I2C serial communication. The TX and RX ports of the GPS module are connected to GPIO2 and GPIO3 of the board. The board uses USB type C for external power supply. The on board 5 volts powers the GPS module and 3.3 volts powers the OLED display. ## Software development Since the ESP series development boards support Arduino for programming, they are developed using the Arduino IDE. ### GPS Module and OLED display Reading the GPS module directly will get its standard language NMEA[^1] (National Marine Electronics Association), which is a standard data format generally supported by manufacturers in the following form: ``` $GPGGA,110617.00,51XX.XXXXX,N,00009.XXXXX,W,1,05,2.68,129.0,M,50.1,M,,*42 $GPGSA,A,3,06,09,30,07,23,,,,,,,,4.43,2.68,3.53*02 $GPGSV,3,1,11,02,48,298,24,03,05,101,24,05,17,292,20,06,71,227,30*7C $GPGSV,3,2,11,07,47,138,33,09,64,044,28,17,01,199,,19,13,214,*7C $GPGSV,3,3,11,23,29,054,29,29,01,335,,30,29,167,33*4E $GPGLL,51XX.XXXXX,N,00009.XXXXX,W,110617.00,A,A*70 $GPRMC,110618.00,A,51XX.XXXXX,N,00009.XXXXX,W,0.078,,030118,,,A*6A $GPVTG,,T,,M,0.043,N,0.080,K,A*2C ``` We only need information about the time and location coordinates, and we only need to focus on the GPGGA column at the beginning. Where `110617.00` means 11:06:17 UTC, `51XX.XXXXXX, N` means 51.XXXXXXXX degrees North, `00009.XXXXXX, W` means 0.09XXXXX degrees West. In this project, the TinyGPSPlus[^2] library and U8g2[^3] library are used for quick development. The base code is as follows: ```C++ #include <Arduino.h> #include <U8g2lib.h> #ifdef U8X8_HAVE_HW_SPI #include <SPI.h> #endif #ifdef U8X8_HAVE_HW_I2C #include <Wire.h> #endif #include <TinyGPSPlus.h> #include <SoftwareSerial.h> static const int RXPin 3, TXPin 2; static const uint32_t GPSBaud 4800; #define time_delay 2000 U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset */ U8X8_PIN_NONE, /* clock */ 9, /* data */ 8); // The TinyGPSPlus object TinyGPSPlus gps; // The serial connection to the GPS device SoftwareSerial ss(RXPin, TXPin); int a; void setup() { u8g2.begin(); Serial.begin(115200); ss.begin(GPSBaud); a 0; } void loop() { u8g2.sendBuffer(); u8g2.clearBuffer(); u8g2_prepare(); a + 1; char b char(a); u8g2.drawStr(80, 0, &b); u8g2_GPS_data(gps.location.lat(), gps.location.lng()); printDateTime(gps.time); smartDelay(1000); if (millis() > 5000 && gps.charsProcessed() < 10) u8g2_No_GPS_data(); u8g2.sendBuffer(); } static void smartDelay(unsigned long ms) { unsigned long start millis(); do { while (ss.available()) gps.encode(ss.read()); } while (millis() start < ms); } void u8g2_prepare(void) { u8g2.setFont(u8g2_font_6x10_tf); u8g2.setFontRefHeightExtendedText(); u8g2.setDrawColor(1); u8g2.setFontPosTop(); u8g2.setFontDirection(0); } void u8g2_No_GPS_data() { u8g2.drawStr(0, 30, \"No GPS data received\"); } void u8g2_GPS_data(float lat, float lng) { u8g2.drawStr(0, 0,\"Lat: \"); char buffer1[10]; dtostrf(lat, 6, 3, buffer1); u8g2.drawStr(25,0,buffer1); u8g2.drawStr(0, 10,\"Lng: \"); char buffer2[10]; dtostrf(lng, 6, 3, buffer2); u8g2.drawStr(25,10,buffer2); } static void printDateTime(TinyGPSTime &t) { if (!t.isValid()) { u8g2.drawStr(0, 20,\"******\");; } else { char sz[32]; sprintf(sz, \"%02d:%02d:%02d \", t.hour(), t.minute(), t.second()); u8g2.drawStr(0, 20,\"Time: \"); u8g2.drawStr(36, 20, sz); } smartDelay(0); } ``` ### Bluetooth Low Energy Bluetooth Low Energy (BLE) is an energy efficient variant of Bluetooth. The main application of BLE is the transmission of small amounts of data over short distances (low bandwidth). Unlike always on Bluetooth, BLE is always in sleep mode unless a connection is initiated. This makes it consume very low power. ```C++ #include <BLEDevice.h> #include <BLEUtils.h> #include <BLEServer.h> #define SERVICE_UUID \"**************************\" #define CHARACTERISTIC_UUID \"**************************\" void setup() { Serial.begin(115200); Serial.println(\"Starting BLE\"); BLEDevice::init(\"Long name works now\"); BLEServer *pServer BLEDevice::createServer(); BLEService *pService pServer >createService(SERVICE_UUID); BLECharacteristic *pCharacteristic pService >createCharacteristic( CHARACTERISTIC_UUID, BLECharacteristic::PROPERTY_READ BLECharacteristic::PROPERTY_WRITE ); pCharacteristic >setValue(\"Hello World says Neil\"); pService >start(); BLEAdvertising *pAdvertising BLEDevice::getAdvertising(); pAdvertising >addServiceUUID(SERVICE_UUID); pAdvertising >setScanResponse(true); pAdvertising >setMinPreferred(0x12); BLEDevice::startAdvertising(); } void loop() { delay(2000); } ``` [^1]: https://www.nmea.org/ [^2]: https://github.com/mikalhart/TinyGPSPlus [^3]: https://github.com/olikraus/u8g2"},"/IoT_QMUL/docs/get_started/en/problem_statement/problem_statement.html":{"title":"Problem Statement","content":" title: Problem Statement ## SSM1: Problem definition > The smart device needs to record the user's location coordinates at a high frequency and save them locally (or back them up every few days), and connect by Bluetooth on a mobile phone for data transfer to visualize the footprint of a web page in a browser. ### Main people involved: People who love to record or travel. ### Challenges Efficient device for continuous recording of location information: apps for mobile phones take up a lot of power and memory while requiring apps to be on all the time, but apps are accidentally or automatically cleaned in the background. Secure storage and recall of data: the company or server side of the mobile app has a large amount of data about the user. Potential security. ### System boundaries Users' activity space. The device calls the sensor every few seconds. GPS module receives signals from satellites. ### Important processes Record GPS information for a long period of time. Transmission of information via Bluetooth communication. Visualization of user's data. Data storage. ### Technology helps the problem Use Network Attached Storage (NAS) or some other decentralized server such as the [Solid](https://solidproject.org/about) project for data storage. Some series of [ESP](https://www.espressif.com/en/products/socs/esp32 c3) with low power and slim volume. ## SSM2: Problem Situation Expression There are two main use cases that work as diagrams below. ### Use case1: Location recording scene ![](../../assets/images/case1.png) The card regularly calls up GPS information and stores the data by detecting whether the user is moving or not. ### Use case2: Data transfer & backup scene ![](../../assets/images/case2.png) Cards are privacy secured through decentralized servers. Footprint visualization using Bluetooth on mobile phones."},"/IoT_QMUL/docs/get_started/en/index.html":{"title":"Introduction","content":" title: Introduction Who doesn't want to know what places they've been to in the past? As a record of their travels or bits of their life. Too many details of travelling are easily forgotten, so this project is designed to record people's life track data by designing a piece of what I call `Footprint Card`, and subsequently visualize the track through a webpage, hoping to recall some forgotten travel memories. This coursework approaches this problem using Soft Systems Methodology (SSM)."},"/IoT_QMUL/docs/get_started/en/requirement_analysis/requirement_analysis.html":{"title":"Requirement Analysis","content":" title: Requirement Analysis ## Functional Requirements Requirements Priority Use GPS module to get location coordinate information Essential Data storage and backup Essential OLED screen displaying data Optional Bluetooth matching and transmission Essential Visual Web Development Optional ## Hardware Requirements ### Board selection The main Boards available in the market are Arduino series, ESP series and STM32 series. Some boards in Arduino and esp are selected for this project, as the project wants the device to be small enough and low power consumption, some types of Boards are selected to be shown in the table below. Board Name PCB Size (mm) Flash Memory Wi Fi Bluetooth Power consumption Price (￡) Arduino Nano[^1] 18 x 45 x 2.6 32 KB N N normal 21.6 Arduino Nano 33 IoT[^2] 18 x 45 x 2.6 1 MB Y Y low 22.8 ESP32 C3 mini[^3] 13.20 × 16.60 x 2.4 4 MB Y Y low 9.90 Based on functional requirements, cost and size considerations, the **ESP32 C3 mini** is chosen for this project. ### Other selection GPS Module: Ultimate GPS Breakout V3 Screen: 0.96 Inch OLED I2C Display 128 x 64: Used to display some simple information as well as to develop user interaction possibilities for subsequent extensions. Breadboard External power supply: As this is a prototype development, no built in power supply module has been designed, and the project focuses on verifying GPS related. Smartphone Jumper Cables and connecting wires ## Software Requirements Arduino IDE: ESP supports Arduino for programming, which is obviously more efficient and convenient. U8g2 Library for screen development TinyGPSPlus Library for GPS development HTML + CSS + JS for web design [^1]: https://store.arduino.cc/products/arduino nano [^2]: https://store.arduino.cc/products/arduino nano 33 iot [^3]: https://www.wemos.cc/en/latest/c3/c3_mini.html"},"/IoT_QMUL/docs/get_started/en/\\no_translate.html":{"title":"no translation","content":" title: no translation class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">This page not translated yet</div> <div> <span id \"visit_hint\">Please visit</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}